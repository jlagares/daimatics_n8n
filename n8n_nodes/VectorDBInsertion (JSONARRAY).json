{
  "name": "VectorDBInsertion (JSONARRAY)",
  "nodes": [
    {
      "parameters": {
        "options": {
          "allowFileUploads": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.3,
      "position": [
        -592,
        -16
      ],
      "id": "b97d7ab4-2d1e-4c34-9a3f-d56bf99a7a08",
      "name": "Upload the JSONL documents",
      "webhookId": "e1ecbd63-65b0-44c0-8ce9-784503529d36"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBearerAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "input",
              "value": "=title: {{ $json.title }}\nheadings: {{ $json.headings }}\ntext: {{ $json.text }}"
            },
            {
              "name": "model",
              "value": "text-embedding-3-small"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -64,
        -16
      ],
      "id": "60f5e099-2f66-4f4d-b31b-d054eaffa63c",
      "name": "HTTP Request",
      "credentials": {
        "httpBearerAuth": {
          "id": "KRta7WZ1YV7TnHI2",
          "name": "OpenAI Bearer"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Get the stringified JSON array from the Chat node\nconst raw = $json.chatInput || '[]';\n\nlet parsed;\ntry {\n  parsed = JSON.parse(raw);\n} catch (e) {\n  throw new Error('Failed to parse chatInput as JSON array');\n}\n\n// Return each object as a separate item\nreturn parsed.map(obj => ({ json: obj }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -320,
        -16
      ],
      "id": "c62bd1d6-cf76-4d9f-9851-5cdf532ae67d",
      "name": "Code in JavaScript"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node — process ALL items coming from HTTP Request\n// and pair each one with the corresponding source item from \"Code in JavaScript\"\n\nconst httpItems = $input.all();                      // items from HTTP Request (embeddings)\nconst srcItems  = $items('Code in JavaScript');      // aligned source items\n\nconst outItems = httpItems.map((it, idx) => {\n  const resp = it.json || {};\n  const src  = (srcItems[idx] && srcItems[idx].json) ? srcItems[idx].json : {};\n\n  // helpers to normalize inputs that might already be JSON strings\n  const parseMaybeJson = (v) => {\n    if (typeof v === 'string') {\n      try { return JSON.parse(v); } catch { return v; }\n    }\n    return v;\n  };\n\n  // headings: array of strings -> CSV\n  const rawHeadings = parseMaybeJson(src.headings);\n  const headingsCsv = Array.isArray(rawHeadings)\n    ? rawHeadings.map(s => String(s)).join(',')\n    : String(rawHeadings ?? '');\n\n  // entities: array of objects -> join by .text, or array of strings -> join\n  const rawEntities = parseMaybeJson(src.entities);\n  let entitiesCsv = '';\n  if (Array.isArray(rawEntities)) {\n    entitiesCsv = rawEntities\n      .map(e => (e && typeof e === 'object') ? e.text : e)\n      .filter(v => v != null && v !== '')\n      .map(s => String(s))\n      .join(',');\n  } else {\n    entitiesCsv = String(rawEntities ?? '');\n  }\n\n  // tags: already CSV if string, else join array\n  const tagsCsv = Array.isArray(src.tags) ? src.tags.join(',') : (src.tags ?? '');\n\n  const embeddingArray = Array.isArray(resp.data?.[0]?.embedding)\n    ? resp.data[0].embedding\n    : [];\n\n  const out = {\n    company:   src.entities?.[0]?.text ?? null,\n    url:       src.url ?? null,\n    title:     src.title ?? null,\n    headings:  headingsCsv,                               // CSV string\n    tags:      tagsCsv,                                   // CSV string\n    entities:  entitiesCsv,                               // CSV string\n    language:  src.language ?? null,\n    last_seen: src.last_seen || '',                       // '' -> NULL via SQL\n    text:      src.text ?? '',\n    tokens:    String(parseInt(resp.usage?.total_tokens ?? src.tokens ?? 0, 10)),\n    hash:      src.hash ?? null,\n    embedding: '[' + embeddingArray.map(Number).filter(Number.isFinite).join(',') + ']'\n  };\n\n  return { json: out };\n});\n\nreturn outItems;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        144,
        -16
      ],
      "id": "1e33748d-d1c0-4e24-bff3-00277088539b",
      "name": "Code in JavaScript1"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO rag.docs (\n  id, hash, embedding,company,url,title, text, tags , headings, entities, language, tokens, last_seen\n  -- , , last_seen\n) VALUES (\n  gen_random_uuid(),        -- id auto\n  $1,                       -- hash\n  $2::vector,               -- embedding (pgvector)\n  $3,                       -- company\n  $4,                       -- url\n  $5,                       -- title\n  $6,                        -- text\n  $7,                        -- tags\n  $8,                          -- headings\n  $9,                         -- entities\n  $10,                       -- language\n  $11,                       -- tokens\n  $12                         -- last_seen\n)\nON CONFLICT (hash) DO UPDATE SET\n  company   = EXCLUDED.company,\n  url       = EXCLUDED.url,\n  title     = EXCLUDED.title,\n  text      = EXCLUDED.text,\n  embedding = EXCLUDED.embedding,\n  tags      = EXCLUDED.tags,\n  headings  = EXCLUDED.headings,\n  entities  = EXCLUDED.entities,\n  language  = EXCLUDED.language,  \n  tokens    = EXCLUDED.tokens,\n  last_seen = EXCLUDED.last_seen\n\n",
        "options": {
          "queryReplacement": "={{ $json.hash }},{{ $json.embedding }},{{ $json.company }}, {{ $json.url }}, {{ $json.title }},{{ $json.text }},{{ $json.tags }}, {{ $json.headings }}, {{ $json.entities }}, {{ $json.language }}, , {{ $json.tokens }}, {{ $json.last_seen }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        368,
        -16
      ],
      "id": "d81d1102-9899-4b2f-83e5-1acce78644c4",
      "name": "PG Upsert",
      "credentials": {
        "postgres": {
          "id": "a39zylCis3kNQMSm",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DROP TABLE IF EXISTS rag.docs CASCADE;\nCREATE TABLE IF NOT EXISTS rag.docs (\n  id              UUID PRIMARY KEY,\n  hash            TEXT UNIQUE,                      -- idempotency on identical text\n  embedding       vector(1536),                      -- set dim to your model\n  company         TEXT NOT NULL,                    -- <-- for your company index\n  url             TEXT NOT NULL,\n  title           TEXT,\n  headings        TEXT,\n  tags            TEXT,\n  entities        TEXT,\n  language        TEXT,\n  last_seen       TEXT,\n  text            TEXT NOT NULL,                    -- unchunked chunk text\n  tokens          TEXT\n\n);\n\nselect * from rag.docs;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -400,
        -224
      ],
      "id": "0e89b25f-a580-4e65-8c93-c810beeadd38",
      "name": "PG Rework",
      "credentials": {
        "postgres": {
          "id": "a39zylCis3kNQMSm",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Enable pgvector\nCREATE EXTENSION IF NOT EXISTS vector;\n\n-- Choose a dim that matches your embedding model\n-- e.g., OpenAI text-embedding-3-large = 3072, text-embedding-3-small = 1536\n-- Cohere/embed-multilingual-v3.0 = 1024; local models vary.\n-- I'll assume 1536 here; change if needed.\nCREATE SCHEMA IF NOT EXISTS rag;\n\nCREATE TABLE IF NOT EXISTS rag.docs (\n  id              UUID PRIMARY KEY,\n  hash            TEXT UNIQUE,                      -- idempotency on identical text\n  embedding       vector(1536),                      -- set dim to your model\n  company         TEXT NOT NULL,                    -- <-- for your company index\n  url             TEXT NOT NULL,\n  title           TEXT,\n  headings        TEXT,\n  tags            TEXT,\n  entities        TEXT,\n  language        TEXT,\n  last_seen       TEXT,\n  text            TEXT NOT NULL,                    -- unchunked chunk text\n  tokens          TEXT\n\n);\n\n-- Fast lookup by company + metadata\nCREATE INDEX IF NOT EXISTS docs_company_idx     ON rag.docs (company);\nCREATE INDEX IF NOT EXISTS docs_url_idx         ON rag.docs (url);\nCREATE INDEX IF NOT EXISTS docs_language_idx    ON rag.docs (language);\nCREATE INDEX IF NOT EXISTS docs_tags_gin        ON rag.docs (tags);\n\n-- -- Vector ANN index (choose one; HNSW requires pgvector ≥0.6, Postgres ≥15)\n-- -- HNSW (great default):\nCREATE INDEX IF NOT EXISTS docs_emb_hnsw\nON rag.docs USING hnsw (embedding vector_l2_ops) WITH (m=16, ef_construction=200);\n\n-- If you prefer IVF-Flat (older pgvector):\n-- CREATE INDEX IF NOT EXISTS docs_emb_ivf\n-- ON rag.docs USING ivfflat (embedding vector_l2_ops) WITH (lists=100);\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -400,
        -384
      ],
      "id": "7c3f7bc8-0ea9-4ca1-af32-cdc0e863b90f",
      "name": "Basic PG Setup, run once!1",
      "credentials": {
        "postgres": {
          "id": "a39zylCis3kNQMSm",
          "name": "Postgres account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Upload the JSONL documents": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "PG Upsert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "8ede49be-b50f-4183-8936-50b9a1c51108",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "289f7ddf5519cdf7575cb365c0aa3aae40fd3979ae828592c8f8641fe42f235e"
  },
  "id": "cCBC6lD2yTltZdSU",
  "tags": []
}